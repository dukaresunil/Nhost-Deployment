"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});var y=require("jwt-decode"),l=require("xstate"),r=require("@nhost/core");function T(s){return s&&typeof s=="object"&&"default"in s?s:{default:s}}var m=T(y);const _=()=>typeof window!="undefined",u=s=>!s||!s.accessToken.value||!s.refreshToken.value||!s.accessToken.expiresAt||!s.user?null:{accessToken:s.accessToken.value,accessTokenExpiresIn:(s.accessToken.expiresAt.getTime()-Date.now())/1e3,refreshToken:s.refreshToken.value,user:s.user},c=({accessToken:s,isError:e,user:t,error:n})=>e?{session:null,error:n}:t&&s?{session:{accessToken:s,accessTokenExpiresIn:0,refreshToken:"",user:t},error:null}:{session:null,error:null};class E{constructor({url:e,autoRefreshToken:t=!0,autoSignIn:n=!0,autoLogin:i,clientStorage:o,clientStorageType:a,clientStorageGetter:h,clientStorageSetter:f,refreshIntervalTime:w,start:g=!0}){var d;this.url=e,this._client=new r.AuthClient({backendUrl:e,clientUrl:typeof window!="undefined"&&((d=window.location)==null?void 0:d.origin)||"",autoRefreshToken:t,autoSignIn:typeof i=="boolean"?i:n,start:g,clientStorage:o,clientStorageType:a,clientStorageGetter:h,clientStorageSetter:f,refreshIntervalTime:w})}async signUp(e){const t=await this.waitUntilReady(),{email:n,options:i}=e;return"securityKey"in e?c(await r.signUpEmailSecurityKeyPromise(t,n,i)):c(await r.signUpEmailPasswordPromise(t,n,e.password,i))}async signIn(e){const t=await this.waitUntilReady();if(!e){const n=await r.signInAnonymousPromise(t);return{...c(n),mfa:null}}if("provider"in e){const{provider:n,options:i}=e,o=r.encodeQueryParameters(`${this._client.backendUrl}/signin/provider/${n}`,r.rewriteRedirectTo(this._client.clientUrl,i));return _()&&(window.location.href=o),{providerUrl:o,provider:n,session:null,mfa:null,error:null}}if("email"in e&&"password"in e){const n=await r.signInEmailPasswordPromise(t,e.email,e.password);return n.needsEmailVerification?{session:null,mfa:null,error:r.EMAIL_NEEDS_VERIFICATION}:n.needsMfaOtp?{session:null,mfa:n.mfa,error:null}:{...c(n),mfa:null}}if("email"in e&&"securityKey"in e){if(e.securityKey!==!0)throw Error("securityKey must be true");const n=await r.signInEmailSecurityKeyPromise(t,e.email);return{...c(n),mfa:null}}if("email"in e){const{email:n,options:i}=e,{error:o}=await r.signInEmailPasswordlessPromise(t,n,i);return{session:null,mfa:null,error:o}}if("phoneNumber"in e&&"otp"in e){const n=await r.signInSmsPasswordlessOtpPromise(t,e.phoneNumber,e.otp);return{...c(n),mfa:null}}if("phoneNumber"in e){const{error:n}=await r.signInSmsPasswordlessPromise(t,e.phoneNumber,e.options);return{error:n,mfa:null,session:null}}if("otp"in e){const n=await r.signInMfaTotpPromise(t,e.otp,e.ticket);return{...c(n),mfa:null}}return{error:r.INVALID_SIGN_IN_METHOD,mfa:null,session:null}}async signOut(e){const t=await this.waitUntilReady(),{error:n}=await r.signOutPromise(t,e==null?void 0:e.all);return{error:n}}async resetPassword({email:e,options:t}){const n=l.interpret(r.createResetPasswordMachine(this._client)).start(),{error:i}=await r.resetPasswordPromise(n,e,t);return{error:i}}async changePassword({newPassword:e,ticket:t}){const n=l.interpret(r.createChangePasswordMachine(this._client)).start(),{error:i}=await r.changePasswordPromise(n,e,t);return{error:i}}async sendVerificationEmail({email:e,options:t}){const n=l.interpret(r.createSendVerificationEmailMachine(this._client)).start(),{error:i}=await r.sendVerificationEmailPromise(n,e,t);return{error:i}}async changeEmail({newEmail:e,options:t}){const n=l.interpret(r.createChangeEmailMachine(this._client)).start(),{error:i}=await r.changeEmailPromise(n,e,t);return{error:i}}async deanonymize(e){const t=await this.waitUntilReady();if(e.signInMethod==="passwordless"){if(e.connection==="email"){const{error:n}=await r.signInEmailPasswordlessPromise(t,e.email,e.options);return{error:n}}if(e.connection==="sms"){const{error:n}=await r.signInSmsPasswordlessPromise(t,e.phoneNumber,e.options);return{error:n}}}if(e.signInMethod==="email-password"){const{error:n}=await r.signUpEmailPasswordPromise(t,e.email,e.password,e.options);return{error:n}}throw Error("Unknown deanonymization method")}async addSecurityKey(e){const{error:t,key:n}=await r.addSecurityKeyPromise(this._client,e);return{error:t,key:n}}onTokenChanged(e){const t=n=>n.onTransition(({event:i,context:o})=>{i.type==="TOKEN_CHANGED"&&e(u(o))});if(this._client.interpreter){const n=t(this._client.interpreter);return()=>n.stop()}else return this._client.onStart(n=>{t(n.interpreter)}),()=>{console.log("onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.")}}onAuthStateChanged(e){const t=n=>n.onTransition(({event:i,context:o})=>{(i.type==="SIGNED_IN"||i.type==="SIGNED_OUT")&&e(i.type,u(o))});if(this._client.interpreter){const n=t(this._client.interpreter);return()=>n.stop()}else return this._client.onStart(n=>{t(n.interpreter)}),()=>{console.log("onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.")}}isAuthenticated(){var e;return!!((e=this._client.interpreter)!=null&&e.state.matches({authentication:"signedIn"}))}async isAuthenticatedAsync(){return(await this.waitUntilReady()).state.matches({authentication:"signedIn"})}getAuthenticationStatus(){var t;const e=((t=this.client.interpreter)==null?void 0:t.getSnapshot().context.importTokenAttempts)||0;return this.isReady()?{isAuthenticated:this.isAuthenticated(),isLoading:!1,connectionAttempts:e}:{isAuthenticated:!1,isLoading:!0,connectionAttempts:e}}getJWTToken(){return this.getAccessToken()}getAccessToken(){var e,t;return(t=(e=this._client.interpreter)==null?void 0:e.state.context.accessToken.value)!=null?t:void 0}getDecodedAccessToken(){const e=this.getAccessToken();return e?m.default(e):null}getHasuraClaims(){var e;return((e=this.getDecodedAccessToken())==null?void 0:e["https://hasura.io/jwt/claims"])||null}getHasuraClaim(e){var t;return((t=this.getHasuraClaims())==null?void 0:t[e.startsWith("x-hasura-")?e:`x-hasura-${e}`])||null}async refreshSession(e){try{const t=await this.waitUntilReady();return new Promise(n=>{const i=e||t.state.context.refreshToken.value;if(!i)return n({session:null,error:r.NO_REFRESH_TOKEN});const{changed:o}=t.send("TRY_TOKEN",{token:i});if(!o)return n({session:null,error:r.TOKEN_REFRESHER_RUNNING_ERROR});t.onTransition(a=>{a.matches({token:{idle:"error"}})?n({session:null,error:r.INVALID_REFRESH_TOKEN}):a.event.type==="TOKEN_CHANGED"&&n({session:u(a.context),error:null})})})}catch(t){return{session:null,error:t.message}}}getSession(){var e,t;return u((t=(e=this._client.interpreter)==null?void 0:e.state)==null?void 0:t.context)}getUser(){var e,t,n;return((n=(t=(e=this._client.interpreter)==null?void 0:e.state)==null?void 0:t.context)==null?void 0:n.user)||null}waitUntilReady(){const t=this._client.interpreter;if(!t)throw Error("Auth interpreter not set");return t.state.hasTag("loading")?new Promise((n,i)=>{let o=setTimeout(()=>i(`The state machine is not yet ready after ${15} seconds.`),15e3);t.onTransition(a=>{if(!a.hasTag("loading"))return clearTimeout(o),n(t)})}):Promise.resolve(t)}isReady(){var e,t;return!((t=(e=this._client.interpreter)==null?void 0:e.state)!=null&&t.hasTag("loading"))}get client(){return this._client}}exports.HasuraAuthClient=E;
//# sourceMappingURL=index.cjs.js.map
