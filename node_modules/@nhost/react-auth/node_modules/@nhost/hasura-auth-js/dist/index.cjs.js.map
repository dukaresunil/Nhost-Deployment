{"version":3,"file":"index.cjs.js","sources":["../src/utils/helpers.ts","../src/hasura-auth-client.ts"],"sourcesContent":["import { AuthContext, NhostSession, SessionActionHandlerResult, SignUpResponse } from '@nhost/core'\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\n\nimport {\n  addSecurityKeyPromise,\n  AuthClient,\n  AuthInterpreter,\n  changeEmailPromise,\n  ChangeEmailResponse,\n  changePasswordPromise,\n  ChangePasswordResponse,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine,\n  DeanonymizeResponse,\n  EMAIL_NEEDS_VERIFICATION,\n  encodeQueryParameters,\n  ErrorPayload,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostSessionResponse,\n  NO_REFRESH_TOKEN,\n  resetPasswordPromise,\n  ResetPasswordResponse,\n  rewriteRedirectTo,\n  SecurityKey,\n  sendVerificationEmailPromise,\n  SendVerificationEmailResponse,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  SignInResponse,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  SignOutResponse,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  SignUpResponse,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from '@nhost/core'\n\nimport { getAuthenticationResult, getSession, isBrowser } from './utils/helpers'\nimport {\n  AuthChangedFunction,\n  ChangeEmailParams,\n  ChangePasswordParams,\n  DeanonymizeParams,\n  NhostAuthConstructorParams,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  SendVerificationEmailParams,\n  SignInParams,\n  SignUpParams\n} from './utils/types'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    autoLogin,\n    clientStorage,\n    clientStorageType,\n    clientStorageGetter,\n    clientStorageSetter,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === 'boolean' ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: ErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.state.matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * @internal\n   * @deprecated Use `nhost.auth.getAccessToken()` instead.\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n\n  getJWTToken(): string | undefined {\n    return this.getAccessToken()\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.state.context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.state.context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.state?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.state?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.state.hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.state?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":["isBrowser","getSession","context","getAuthenticationResult","accessToken","isError","user","error","HasuraAuthClient","url","autoRefreshToken","autoSignIn","autoLogin","clientStorage","clientStorageType","clientStorageGetter","clientStorageSetter","refreshIntervalTime","start","AuthClient","_a","params","interpreter","email","options","signUpEmailSecurityKeyPromise","signUpEmailPasswordPromise","anonymousResult","signInAnonymousPromise","provider","providerUrl","encodeQueryParameters","rewriteRedirectTo","res","signInEmailPasswordPromise","EMAIL_NEEDS_VERIFICATION","signInEmailSecurityKeyPromise","signInEmailPasswordlessPromise","signInSmsPasswordlessOtpPromise","signInSmsPasswordlessPromise","signInMfaTotpPromise","INVALID_SIGN_IN_METHOD","signOutPromise","service","interpret","createResetPasswordMachine","resetPasswordPromise","newPassword","ticket","createChangePasswordMachine","changePasswordPromise","createSendVerificationEmailMachine","sendVerificationEmailPromise","newEmail","createChangeEmailMachine","changeEmailPromise","nickname","key","addSecurityKeyPromise","fn","listen","event","subscription","client","connectionAttempts","_b","jwt","jwt_decode","name","refreshToken","resolve","token","NO_REFRESH_TOKEN","changed","TOKEN_REFRESHER_RUNNING_ERROR","state","INVALID_REFRESH_TOKEN","_c","reject","timer"],"mappings":"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"}